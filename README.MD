Привет.

Это еще один шаблонизатор для PHP
Некоторые заказчики, которым нужно было привести в порядок старый код и 
добавить новую функциональность, резко возражали против использования 
сторонних шаблонизаторов. Переубедить их не удалось, пришлось делать свой.
В сравнении с множеством прочих, этот шаблонизатор примитивен - состоит 
всего из двух классов и не имеет никаких расширенных возможностей, вроде 
собственного языка, переменных и прочего.
Принцип работы прост - требовалось разделить старый код, в котором все было
свалено в одну кучу, на html и php. Например:

                        <html>
                            <body>
                               Сегодня = <?php echo date( 'd.m.Y' ); />
                            </body>                            
                        </html>
                    
Соответственно, html-код переносим в файл шаблона, например, view.tpl:

                        <html>
                            <body>
                               Сегодня = %DATE%
                            </body>                            
                        </html>
                    
а код, вычисляющий дату, переносим в файл view.php, где только код php и никакого html:

                        <?php>
                            require_once 'Template.class.php';
                            use template\Template;

                            $templateFileName = 'view.tpl';
                            $map = array(
                                '%DATE%' => date( 'd.m.Y' )
                            );
                            echo Template::toHtml( $templateFileName, $map );
                    
Теперь, при выполнении этого php-кода, текущая дата будет вычислена, помещена в
массив $map, как значение ключа '%DATE%', из переменной $templateFileName будет
взято имя файла шаблона, и в шаблоне все строки вида %DATE% буду заменены 
значением $map[ '%DATE%' ]. Сгенерированный html-код будет отправлен пользователю 
с помощью echo. Разумеется, в массив $map можно добавить столько разных значений, 
сколько их должно быть на результирующей странице, например:

                $map = array(
                    '%CELSIUS_TEMPERATURE%' => 36.6,
                    '%TIME%' => '23:11:45',
                    '%SELECT_ROW_COLOR%' => 'green'
                );
            
и тому подобное.
Еще бывает нужно выводить на страницу не одиночные данные, а списки значений. 
Например, чтобы сформировать на странице раскрывающийся список, нужно не одно значение,
а формируемые элементы однообразны. Отображать их по одиночке с помощью 
класса Template очень муторно (хотя и можно):

                <select>
                    <option>23.56</option>
                    <option selected>34.48</option>
                    <option>40.06</option>
                <select>
            
Для того, чтобы формировать подобные структуры, используем другой 
класс: TemplateWithList. Он аналогично классу Template может формировать результат 
по шаблону и одиночным данным, а также умеет работать со списком значений:

                        <?php>
                            require_once 'TemplateWithList.class.php';
                            use template\TemplateWithList;

                            $templateFileName = 'view.tpl';
                            $map = array(
                                '%LIST%' => array(
                                    '%ITEM%' => 'item',
                                    '%MODE%' => 'mode',
                                    array(
                                        array( 'item' => 23.56, 'mode' => '' ),
                                        array( 'item' => 34.48, 'mode' => 'selected' ),
                                        array( 'item' => 40.06, 'mode' => '' ),
                                    )
                                )
                            );
                            echo TemplateWithList::toHtml( $templateFileName, $map );                
            
Шаблон для формирования структуры по списку будет таким:

                <select>
                    %LIST%
                        <option %MODE%>%ITEM%</option>
                    %LIST%
                <select>                
            
Здесь первое появление %LIST% обозначает начало шаблона для элемента списка, 
а второе появление %LIST% - завершение этого шаблона. Строки вида '%ITEM%' => 'item' - связывают 
имя подстановки (%ITEM%) и имя ключа в списке из которого будут браться значения 
для этого имени. Для каждого значения вида array( 'item' => '23.56', 'mode' => '' ) 
из $map будет в результате создан текст по шаблону <option %MODE%>%ITEM%</option>.
В одном $map таких списков может быть несколько, одновременно можно задавать данные 
для одиночных значений. Если нужно, можно шаблон задавать не в отдельном файле, а 
прямо в строковой переменой. Для этого немного изменим вызов:

                        <?php>
                            require_once 'Template.class.php';
                            use template\Template;

                            $templateFileName = '';
                            $map = array(
                                '%DATE%' => date( 'd.m.Y' )
                            );
                            $template = '<div>Сегодня = %DATE%</div>';
                            echo Template::toHtml( $templateFileName, $map, $template );                
            
Если имя файла шаблона - пустая строка, то шаблонизатор решит, что шаблон нужно 
искать прямо в строковой переменной. Эту строковую переменную нужно дать третьим
параметром при вызове Template::toHtml(). Какой из классов - Template или TemplateWithList - лучше 
использовать в каких условиях? Я всегда использую TemplateWithList, поскольку он 
умеет обрабатывать и одиночные значения и списки. Поскольку Template и TemplateWithList классы, 
а современный PHP умеет перекрывать (override) статические методы,то при необходимости 
вы можете на базе этих классов создать свой со специфическим поведением.
Если вы работаете с unit-тестами, то загляните в папку test - там лежат unit-тесты 
для обоих классов ( тесты написаны с использованием simpletest, сам simpletest тоже прилагается ).
Если что-то неправильно работает - пишите.

